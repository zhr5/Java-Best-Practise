package com.javaedge.algorithm.leetcode.matrix;

public class Solution48 {
    /*  1 2 3       7  4  1
        4 5 6       8  5  2
        7 8 9       9  6  3
        */
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; i++) {//控制着需要处理的 “层”
            for (int j = 0; j < (n + 1) / 2; j++) {//每一层中遍历相应的元素
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];//左上等于左下
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];//左下等于右下
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];//右下等于右上
                matrix[j][n - 1 - i] = tmp;//右上等于左上
            }
        }
    }
}

/*
坐标对应关系
        在一个 n×n 的方阵中，我们通常按照行列的方式来确定元素位置，左上角元素的坐标为[0][0]，也就是第 0行第 0列。沿着行方向向右是列坐标增加，沿着列方向向下是行坐标增加，右下角元素坐标就是[n-1][n-1]（因为索引是从 0开始计数，总共有 n 个元素时，最大索引为 n-1）。
        旋转对应分析
        在代码所实现的顺时针旋转 90度操作中，我们可以将矩阵看作是由多个 “层” 组成（对于外层循环控制的情况，每次处理一层）。当我们进行旋转交换元素时，把矩阵抽象地划分成四个区域：左上角、右上角、左下角、右下角。
        假设我们现在站在处理第 i 层（由外层循环 for(int i=0;i<n /2;i++)所确定的层），对于这一层来说：
        左上角：坐标表示为[i][j]，它是当前正在处理这一层左上角位置的元素，这里的 j 是在内层循环 for(int j=0;j< (n+1)/2;j++)中不断变化，从而遍历这一层左上角区域内的各个元素。
        左下角：坐标为[n-1-j][i]，这里通过 n-1-j （n-1是最后一行的索引，减去 j 可以对应到这一层从下往上数的相应列位置）与固定的 i（当前层对应的行）来定位左下角区域的元素，刚好与左上角区域的元素在旋转交换时有对应关系。
        右下角：坐标是[n-1-i][n-1-j]，n-1-i 表示从下往上数的行位置（对应最后一行往上数到当前层），n-1-j 同样是从右往左数的列位置，以此确定右下角区域元素，该元素在旋转过程中会和左下角等区域元素按顺序交换。
        右上角：坐标为[j][n-1-i]，其原理在于 j 是从左往右数的列位置（在内层循环中变化），n-1-i 是从上往下数的行位置（对应最上面一行往下数到当前层），刚好定位到右上角区域的元素。
        所以在整个旋转元素交换的逻辑中，按照这样的坐标定位，matrix[j][n-1-i]就代表了矩阵中当前层的右上角位置的元素，通过这四个坐标表示的元素依次交换，从而实现了顺时针旋转 90度时对应位置元素的正确替换。*/
