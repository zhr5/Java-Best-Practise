package com.javaedge.algorithm.leetcode.subString;

import java.util.HashMap;

//和为K的子数组
/*      示例 1：
        输入：nums = [1,1,1], k = 2
        输出：2
        示例 2：
        输入：nums = [1,2,3], k = 3
        输出：2*/
/*给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
        子数组是数组中元素的连续非空序列。*/
public class Solution560 {
    public int subarraySum(int[] nums, int k) {
         /*
    使用前缀和的方法可以解决这个问题，因为我们需要找到和为k的连续子数组的个数.
    通过计算前缀和，我们可以将问题转化为求解两个前缀和之差等于k的情况。
    假设数组的前缀和数组为prefixSum，其中prefixSum[i]表示从数组起始位置
    到第i个位置的元素之和。那么对于任意的两个下标i和j（i < j），如果
    prefixSum[j] - prefixSum[i] = k，即从第i个位置到第j个位置的元素之和等于k，
    那么说明从第i+1个位置到第j个位置的连续子数组的和为k。
    通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和
    出现的次数。在遍历的过程中，我们检查是否存在prefixSum[j] - k的前缀和，
    如果存在，说明从某个位置到当前位置的连续子数组的和为k，我们将对应的次数累加到结果中。
    这样，通过遍历一次数组，我们可以统计出和为k的连续子数组的个数，并且时间复杂度为O(n)，其中n为数组的长度。
    */
        int count = 0, pre = 0;
        HashMap<Integer, Integer> mp = new HashMap<>(); //存储和为X值出现的次数
        mp.put(0, 1);//如果没有这个初始化，那么sum-k=0时，map中没有0，判断为false，就会漏掉这种情况
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (mp.containsKey(pre - k)) {
                count += mp.get(pre - k);
            }
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return count;

    }
}
/*
前缀和使用场景：
        1. **区间求和问题**
        - **问题描述**：给定一个数组，需要频繁地查询数组中某个区间内元素的和。例如，有数组 `nums = [1, 2, 3, 4, 5]`，需要多次查询像 `nums[1:4]`（这里表示索引从1到3的元素，即 `2, 3, 4`）这个区间内元素的和。
        - **解决方案**：通过计算前缀和数组 `prefixSum`，其中 `prefixSum[i]` 表示 `nums[0]` 到 `nums[i]` 的元素之和。对于查询区间 `[left, right]` 的和，只需要计算 `prefixSum[right]-prefixSum[left - 1]`（注意当 `left = 0` 时，`prefixSum[left - 1]` 视为0）。例如，对于上述数组，前缀和数组为 `[1, 3, 6, 10, 15]`，查询区间 `[1, 3]` 的和为 `prefixSum[3]-prefixSum[0]=10 - 1 = 9`，正好是 `2 + 3+4` 的和。
        2. **子数组和相关问题**
        - **问题描述**：
        - **给定和的子数组数量问题**：给定一个整数数组和一个目标和，求数组中有多少个子数组的和等于目标和。例如，数组 `nums = [1, 1, 1]`，目标和为 `2`，求有多少个子数组的和为 `2`。
        - **子数组和的最小值/最大值问题**：在一个数组中，找出子数组和的最小值或最大值。
        - **解决方案**：
        - **给定和的子数组数量问题**：先计算前缀和数组。利用哈希表记录前缀和出现的次数。遍历前缀和数组，对于当前前缀和 `prefixSum[i]`，如果 `prefixSum[i]-targetSum`（目标和）在哈希表中出现过，说明存在以当前位置结尾的子数组满足和为目标和，将满足条件的子数组数量累加到结果中。在上述例子中，前缀和数组为 `[1, 2, 3]`，哈希表初始为空。当计算到 `prefixSum[1] = 2` 时，`prefixSum[1]-targetSum = 0`，此时哈希表中没有0这个前缀和，继续；当计算到 `prefixSum[2] = 3` 时，`prefixSum[2]-targetSum = 1`，哈希表中有前缀和为1的情况（之前出现过 `prefixSum[0] = 1`），所以满足条件的子数组数量加1。
        - **子数组和的最小值/最大值问题**：可以通过动态维护前缀和数组，并在更新前缀和的过程中，结合贪心算法或者动态规划的思想来找出子数组和的最值。例如，在计算前缀和的过程中，记录下前缀和的最小值，通过当前前缀和减去之前记录的最小值来更新子数组和的最大值。
        3. **二维区域问题（矩阵问题）**
        - **问题描述**：
        - **子矩阵和问题**：给定一个二维矩阵，求矩阵内某个子矩阵的元素和。例如，有一个 `m×n` 的矩阵，需要查询以 `(r1, c1)` 为左上角，`(r2, c2)` 为右下角的子矩阵的元素和。
        - **最大子矩阵和问题**：在一个二维矩阵中，找出和最大的子矩阵。
        - **解决方案**：
        - **子矩阵和问题**：可以先计算每行的前缀和，然后通过对列的前缀和操作来得到子矩阵的和。具体来说，对于每一行，计算从左到右的前缀和。然后对于子矩阵的上下边界 `r1` 和 `r2`，通过计算列方向上的前缀和（利用之前行方向的前缀和结果）来得到子矩阵的和。例如，对于一个 `3×3` 的矩阵 `matrix`，先计算每行的前缀和，然后如果要求以 `(0, 0)` 为左上角，`(2, 2)` 为右下角的子矩阵和，可以通过行和列方向的前缀和计算得到。
        - **最大子矩阵和问题**：可以通过枚举子矩阵的上下边界，对于每一种上下边界的组合，将问题转化为一维数组的最大子数组和问题（利用列方向的前缀和数组），然后找出所有组合中的最大值。
        4. **字符串匹配问题（部分情况）**
        - **问题描述**：在两个字符串中，判断一个字符串是否可以通过在另一个字符串的前面或后面添加字符得到，并且需要考虑字符的数量匹配情况（可以看作是一种特殊的“和”匹配）。
        - **解决方案**：可以将字符串中的字符转换为数字（例如，`a` 对应1，`b` 对应2等），然后计算前缀和。通过比较前缀和来判断是否满足匹配条件。不过这种方法有一定的局限性，仅适用于特定的字符串匹配场景，如字符只出现一次且顺序相对固定等简单情况。

*/
